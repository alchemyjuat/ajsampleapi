package my_api.configuration.application.listener;
// **********************************************************************
// Code generated by AlchemyJ Compiler.
// PLEASE DO NOT EDIT THIS FILE.
// **********************************************************************

import java.io.File;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import my_api.util.SpringInitializerLogger;
import org.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.event.SmartApplicationListener;
import org.springframework.core.Ordered;
import org.springframework.core.env.MapPropertySource;
import org.springframework.core.env.MutablePropertySources;
import org.springframework.util.StringUtils;

public class ExternalLogConfigApplicationListener implements SmartApplicationListener, Ordered {

  // Level: 1st
  // Name of environment to define external log configuration file path.
  private static final String LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME = "";
  // Level: 2nd
  // External log configuration file path defined from REST package setting.
  private static final String EXTERNAL_LOG_CONFIG_FILE_PATH = "";
  private static final String EQ_STR =
      "=================================================================";

  private static SpringInitializerLogger log = SpringInitializerLogger.getInstance();

  @Override
  public void onApplicationEvent(ApplicationEvent event) {
    if (event instanceof ApplicationEnvironmentPreparedEvent) {
      this.doActionOnApplicationEvent((ApplicationEnvironmentPreparedEvent) event);
    }
  }

  @Override
  public int getOrder() {
    return Ordered.HIGHEST_PRECEDENCE;
  }

  @Override
  public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
    return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType);
  }

  @Override
  public boolean supportsSourceType(Class<?> sourceType) {
    return true;
  }

  private void doActionOnApplicationEvent(ApplicationEnvironmentPreparedEvent event) {
    // 1. Try to read from environment first
    boolean result = this.registerFromEnvironment(event);

    // 2. If fail read from environment, read from user configuration
    if (!result) {
      result = this.registerFromUserSetting(event);
    }

    // If both fail, log configuration file in package will be activated, log this information.
    if (!result) {
      log.info(EQ_STR);
      log.info("Default log configuration file in current package is activated.");
      log.info(EQ_STR);
    }
  }

  private boolean registerFromEnvironment(ApplicationEnvironmentPreparedEvent event) {
    // If user does not defined an environment variable to configure log file, do nothing
    if (StringUtils.isEmpty(LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME)) {
      log.info("No system environment variable defined for application log configuration");
      return false;
    }

    // If environment variable defined by user does not exist in system, do nothing
    if (!event.getEnvironment().containsProperty(LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME)) {
      log.warn(
          "System environment variable(name = {}) does not exist",
          LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME);
      return false;
    }

    String definedLogConfFilePath =
        event.getEnvironment().getProperty(LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME);
    log.info(
        "Load value from system environment, name = {}, value = {}",
        LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME,
        definedLogConfFilePath);
    // If value of defined environment variable is empty or null, do thing
    if (StringUtils.isEmpty(definedLogConfFilePath)) {
      log.warn(
          "Value of system environment variable(name = {}) is empty",
          LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME);
      return false;
    }

    // If value of environment variable points to an non-exist location, do nothing.
    String actuallyLogConfPath = this.calculatePath(definedLogConfFilePath);
    log.info(
        "User defined external log configuration file path: {}, absolute path: {}",
        definedLogConfFilePath,
        actuallyLogConfPath);
    File logConfFile = new File(actuallyLogConfPath);
    if (!logConfFile.exists() || !logConfFile.isFile()) {
      log.warn(
          "File(path = {}, absolute path = {}) does not exist, which is defined by system environment variable(name = {})",
          definedLogConfFilePath,
          actuallyLogConfPath,
          LOG_CONFIG_FILE_PATH_ENV_PROPERTY_NAME);
      return false;
    }
    this.registerLogConfigFile(event, actuallyLogConfPath);
    return true;
  }

  private boolean registerFromUserSetting(ApplicationEnvironmentPreparedEvent event) {
    if (StringUtils.isEmpty(EXTERNAL_LOG_CONFIG_FILE_PATH)) {
      log.info(
          "External log configuration file path is empty, which is defined by REST package setting");
      return false;
    }

    String actuallyLogConfPath = this.calculatePath(EXTERNAL_LOG_CONFIG_FILE_PATH);
    log.info(
        "User defined external log configuration file path: {}, absolute path: {}",
        EXTERNAL_LOG_CONFIG_FILE_PATH,
        actuallyLogConfPath);
    File logConfFile = new File(actuallyLogConfPath);
    if (!logConfFile.exists() || !logConfFile.isFile()) {
      log.warn(
          "File(path = {}, absolute path = {}) does not exist, which is defined by REST package setting",
          EXTERNAL_LOG_CONFIG_FILE_PATH,
          actuallyLogConfPath);
      return false;
    }

    this.registerLogConfigFile(event, EXTERNAL_LOG_CONFIG_FILE_PATH);
    return true;
  }

  private void registerLogConfigFile(ApplicationEnvironmentPreparedEvent event, String filePath) {
    log.info(EQ_STR);
    log.info("Activated external log configuration file: {}", filePath);
    log.info(EQ_STR);

    Map<String, Object> prop = new HashMap<>();
    prop.put("logging.config", filePath);
    MapPropertySource mps = new MapPropertySource("external-log-file", prop);
    MutablePropertySources mutablePs = event.getEnvironment().getPropertySources();
    mutablePs.addFirst(mps);
  }

  private String calculatePath(String sourcePath) {
    try {
      return Paths.get(sourcePath).toFile().getCanonicalPath();
    } catch (Exception e) {
      return Paths.get(sourcePath).toFile().getAbsolutePath();
    }
  }
}
